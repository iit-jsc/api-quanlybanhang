import { Injectable, HttpException, HttpStatus } from '@nestjs/common'
import { PrismaService } from 'nestjs-prisma'
import { ExportInvoicesDto, CreateInvoiceDetailDto, CreateInvoiceDto } from './dto/invoice.dto'
import { VNPTElectronicInvoiceProvider } from './providers'
import { InvoiceStatus } from '@prisma/client'

@Injectable()
export class InvoiceService {
  constructor(
    private readonly prisma: PrismaService,
    private readonly vnptProvider: VNPTElectronicInvoiceProvider
  ) {}
  /**
   * Xu·∫•t nhi·ªÅu h√≥a ƒë∆°n ƒëi·ªán t·ª≠
   */
  async exportInvoices(data: ExportInvoicesDto, accountId: string, branchId: string) {
    const results = []

    for (const invoiceData of data.invoices) {
      try {
        // 1. Validate d·ªØ li·ªáu ƒë·∫ßu v√†o
        this.validateInvoiceData(invoiceData)

        // 2. T·∫°o invoice v√† invoice details trong database
        const invoice = await this.createInvoiceRecord(invoiceData, accountId, branchId)

        // 3. Xu·∫•t h√≥a ƒë∆°n ƒëi·ªán t·ª≠ qua VNPT
        if (data.exportElectronic) {
          const vnptResult = await this.exportToVNPT(invoice, invoiceData)

          // 5. C·∫≠p nh·∫≠t tr·∫°ng th√°i
          await this.updateInvoiceStatus(
            invoice.id,
            vnptResult.success ? InvoiceStatus.SUCCESS : InvoiceStatus.ERROR,
            accountId
          )

          results.push({
            invoiceId: invoice.id,
            success: vnptResult.success,
            message: vnptResult.success ? 'Xu·∫•t h√≥a ƒë∆°n th√†nh c√¥ng' : vnptResult.error,
            vnptData: vnptResult
          })
        } else {
          results.push({
            invoiceId: invoice.id,
            success: true,
            message: 'T·∫°o h√≥a ƒë∆°n th√†nh c√¥ng'
          })
        }
      } catch (error) {
        results.push({
          success: false,
          message: error.message,
          error: error
        })
      }
    }

    return {
      message: 'X·ª≠ l√Ω ho√†n th√†nh',
      results,
      summary: {
        total: data.invoices.length,
        successful: results.filter(r => r.success).length,
        failed: results.filter(r => !r.success).length
      }
    }
  }

  /**
   * L·∫•y danh s√°ch h√≥a ƒë∆°n theo chi nh√°nh
   */
  async getInvoicesByBranch(branchId: string) {
    return this.prisma.invoice.findMany({
      where: { branchId },
      include: {
        order: {
          include: {
            customer: true
          }
        },
        invoiceDetails: true
      },
      orderBy: { createdAt: 'desc' }
    })
  }

  /**
   * L·∫•y th√¥ng tin chi ti·∫øt h√≥a ƒë∆°n
   */
  async getInvoiceById(id: string, branchId: string) {
    const invoice = await this.prisma.invoice.findFirst({
      where: { id, branchId },
      include: {
        order: {
          include: {
            customer: true,
            paymentMethod: true
          }
        },
        invoiceDetails: true
      }
    })

    if (!invoice) {
      throw new HttpException('Kh√¥ng t√¨m th·∫•y h√≥a ƒë∆°n', HttpStatus.NOT_FOUND)
    }
    return invoice
  }
  /**
   * Validate d·ªØ li·ªáu h√≥a ƒë∆°n
   */
  private validateInvoiceData(invoiceData: CreateInvoiceDto): void {
    // Validate ti·ªÅn h√†ng, thu·∫ø, gi·∫£m gi√°
    const calculatedTotal = invoiceData.invoiceDetails.reduce(
      (sum: number, detail: CreateInvoiceDetailDto) => {
        return sum + detail.unitPrice * detail.amount
      },
      0
    )

    const calculatedTax = invoiceData.invoiceDetails.reduce(
      (sum: number, detail: CreateInvoiceDetailDto) => {
        return sum + (detail.vatAmount || 0)
      },
      0
    )

    // Validate t·ªïng ti·ªÅn h√†ng
    if (Math.abs(calculatedTotal - invoiceData.totalBeforeTax) > 0.01) {
      throw new HttpException(
        `T·ªïng ti·ªÅn h√†ng kh√¥ng ch√≠nh x√°c. T√≠nh to√°n: ${calculatedTotal}, Nh·∫≠n ƒë∆∞·ª£c: ${invoiceData.totalBeforeTax}`,
        HttpStatus.BAD_REQUEST
      )
    }

    // Validate t·ªïng ti·ªÅn thu·∫ø
    if (Math.abs(calculatedTax - invoiceData.totalTax) > 0.01) {
      throw new HttpException(
        `T·ªïng ti·ªÅn thu·∫ø kh√¥ng ch√≠nh x√°c. T√≠nh to√°n: ${calculatedTax}, Nh·∫≠n ƒë∆∞·ª£c: ${invoiceData.totalTax}`,
        HttpStatus.BAD_REQUEST
      )
    }

    // Validate t·ªïng ti·ªÅn sau thu·∫ø
    const expectedAfterTax = calculatedTotal + calculatedTax - (invoiceData.totalTaxDiscount || 0)
    if (Math.abs(expectedAfterTax - invoiceData.totalAfterTax) > 0.01) {
      throw new HttpException(
        `T·ªïng ti·ªÅn sau thu·∫ø kh√¥ng ch√≠nh x√°c. T√≠nh to√°n: ${expectedAfterTax}, Nh·∫≠n ƒë∆∞·ª£c: ${invoiceData.totalAfterTax}`,
        HttpStatus.BAD_REQUEST
      )
    }

    // Validate t·ª´ng chi ti·∫øt h√≥a ƒë∆°n
    invoiceData.invoiceDetails.forEach((detail: CreateInvoiceDetailDto, index: number) => {
      if (detail.amount <= 0) {
        throw new HttpException(
          `Chi ti·∫øt ${index + 1}: S·ªë l∆∞·ª£ng ph·∫£i l·ªõn h∆°n 0`,
          HttpStatus.BAD_REQUEST
        )
      }

      if (detail.unitPrice <= 0) {
        throw new HttpException(
          `Chi ti·∫øt ${index + 1}: ƒê∆°n gi√° ph·∫£i l·ªõn h∆°n 0`,
          HttpStatus.BAD_REQUEST
        )
      }

      // Validate VAT n·∫øu c√≥
      if (detail.vatRate && detail.vatAmount) {
        const expectedVat = (detail.unitPrice * detail.amount * detail.vatRate) / 100
        if (Math.abs(expectedVat - detail.vatAmount) > 0.01) {
          throw new HttpException(
            `Chi ti·∫øt ${index + 1}: VAT kh√¥ng ch√≠nh x√°c. T√≠nh to√°n: ${expectedVat}, Nh·∫≠n ƒë∆∞·ª£c: ${detail.vatAmount}`,
            HttpStatus.BAD_REQUEST
          )
        }
      }
    })
  }
  /**
   * T·∫°o b·∫£n ghi h√≥a ƒë∆°n v√† chi ti·∫øt h√≥a ƒë∆°n
   * - N·∫øu h√≥a ƒë∆°n ƒë√£ t·∫°o v·ªõi status SUCCESS th√¨ kh√¥ng t·∫°o l·∫°i
   * - N·∫øu status PENDING ho·∫∑c ERROR th√¨ x√≥a c≈© v√† t·∫°o m·ªõi
   */
  private async createInvoiceRecord(
    invoiceData: CreateInvoiceDto,
    accountId: string,
    branchId: string
  ) {
    // Ki·ªÉm tra h√≥a ƒë∆°n ƒë√£ t·ªìn t·∫°i cho orderId n√†y
    const existingInvoice = await this.prisma.invoice.findUnique({
      where: {
        orderId: invoiceData.orderId,
        branchId
      }
    })

    if (existingInvoice) {
      // N·∫øu ƒë√£ th√†nh c√¥ng th√¨ kh√¥ng t·∫°o l·∫°i
      if (existingInvoice.status === InvoiceStatus.SUCCESS) {
        throw new HttpException(
          `H√≥a ƒë∆°n cho ƒë∆°n h√†ng ${invoiceData.orderId} ƒë√£ ƒë∆∞·ª£c xu·∫•t th√†nh c√¥ng`,
          HttpStatus.CONFLICT
        )
      }

      // N·∫øu PENDING ho·∫∑c ERROR th√¨ x√≥a h√≥a ƒë∆°n c≈© v√† chi ti·∫øt
      if (
        existingInvoice.status === InvoiceStatus.PENDING ||
        existingInvoice.status === InvoiceStatus.ERROR
      ) {
        // X√≥a h√≥a ƒë∆°n (cascade s·∫Ω x√≥a invoice details)
        await this.prisma.invoice.delete({
          where: { id: existingInvoice.id }
        })
      }
    }

    // T·∫°o h√≥a ƒë∆°n m·ªõi v·ªõi chi ti·∫øt trong transaction
    return this.prisma.$transaction(async tx => {
      // T·∫°o h√≥a ƒë∆°n
      const invoice = await tx.invoice.create({
        data: {
          branchId,
          orderId: invoiceData.orderId,
          customerName: invoiceData.customerName,
          originalName: invoiceData.originalName,
          customerTaxCode: invoiceData.customerTaxCode,
          customerAddress: invoiceData.customerAddress,
          customerPhone: invoiceData.customerPhone,
          customerEmail: invoiceData.customerEmail,
          totalBeforeTax: invoiceData.totalBeforeTax,
          totalTax: invoiceData.totalTax,
          totalTaxDiscount: invoiceData.totalTaxDiscount || 0,
          totalAfterTax: invoiceData.totalAfterTax,
          status: InvoiceStatus.PENDING,
          createdBy: accountId
        }
      })

      // T·∫°o chi ti·∫øt h√≥a ƒë∆°n
      await tx.invoiceDetail.createMany({
        data: invoiceData.invoiceDetails.map(detail => ({
          invoiceId: invoice.id,
          productName: detail.productName,
          productCode: detail.productCode,
          unit: detail.unit,
          unitPrice: detail.unitPrice,
          amount: detail.amount,
          vatRate: detail.vatRate
        }))
      })

      return invoice
    })
  }

  /**
   * Xu·∫•t h√≥a ƒë∆°n qua VNPT
   */
  private async exportToVNPT(
    invoice: Awaited<ReturnType<typeof this.createInvoiceRecord>>,
    invoiceData: CreateInvoiceDto
  ) {
    // L·∫•y provider config
    const invoiceProvider = await this.prisma.invoiceProvider.findFirst({
      where: {
        branchId: invoice.branchId,
        providerType: 'VNPT',
        isActive: true
      },
      include: {
        invConfig: true
      }
    })

    if (!invoiceProvider) {
      throw new HttpException('Kh√¥ng t√¨m th·∫•y c·∫•u h√¨nh VNPT', HttpStatus.NOT_FOUND)
    }

    if (!invoiceProvider.invConfig) {
      throw new HttpException('Kh√¥ng t√¨m th·∫•y c·∫•u h√¨nh chi ti·∫øt VNPT', HttpStatus.NOT_FOUND)
    }

    console.log('üîç [Invoice Service] VNPT Provider config loaded:', {
      providerId: invoiceProvider.id,
      hasInvConfig: !!invoiceProvider.invConfig,
      configFields: invoiceProvider.invConfig ? Object.keys(invoiceProvider.invConfig) : [],
      vnptApiUrl: invoiceProvider.invConfig?.vnptApiUrl || 'NOT_SET',
      vnptUsername: invoiceProvider.invConfig?.vnptUsername || 'NOT_SET',
      hasPassword: !!invoiceProvider.invConfig?.vnptPassword,
      hasAccountPassword: !!invoiceProvider.invConfig?.vnptAccountPassword,
      invPattern: invoiceProvider.invConfig?.invPattern || 'NOT_SET',
      invSerial: invoiceProvider.invConfig?.invSerial || 'NOT_SET'
    })

    // Transform to expected provider format with full config
    const providerData = {
      providerType: invoiceProvider.providerType,
      providerName: 'VNPT',
      isActive: invoiceProvider.isActive,
      config: {
        id: invoiceProvider.id,
        providerId: invoiceProvider.id,
        vnptApiUrl: invoiceProvider.invConfig.vnptApiUrl || '',
        vnptLookupUrl: invoiceProvider.invConfig.vnptLookupUrl || '',
        vnptUsername: invoiceProvider.invConfig.vnptUsername || '',
        vnptPassword: invoiceProvider.invConfig.vnptPassword || '',
        vnptAccount: invoiceProvider.invConfig.vnptAccount || '',
        vnptAccountPassword: invoiceProvider.invConfig.vnptAccountPassword || '',
        invPattern: invoiceProvider.invConfig.invPattern || '',
        invSerial: invoiceProvider.invConfig.invSerial || ''
      }
    }

    // Create invoice data with details for VNPT
    const invoiceForVNPT = {
      ...invoice,
      invoiceDetails: invoiceData.invoiceDetails.map(detail => ({
        id: `temp-${Date.now()}-${Math.random()}`, // Temporary ID
        invoiceId: invoice.id,
        productName: detail.productName,
        productCode: detail.productCode,
        unit: detail.unit,
        unitPrice: detail.unitPrice,
        amount: detail.amount,
        vatRate: detail.vatRate,
        vatAmount: detail.vatAmount,
        createdAt: new Date(),
        updatedAt: new Date()
      })),
      order: {
        id: invoiceData.orderId,
        code: `ORD-${invoiceData.orderId.slice(0, 8)}`, // Generate order code
        orderTotal: invoiceData.totalAfterTax,
        customer: {
          name: invoiceData.customerName,
          tax: invoiceData.customerTaxCode,
          address: invoiceData.customerAddress,
          phone: invoiceData.customerPhone,
          email: invoiceData.customerEmail
        },
        paymentMethod: null
      }
    }

    return this.vnptProvider.exportInvoice(providerData, invoiceForVNPT, invoice.totalTax || 0)
  }

  /**
   * C·∫≠p nh·∫≠t tr·∫°ng th√°i h√≥a ƒë∆°n
   */
  private async updateInvoiceStatus(invoiceId: string, status: InvoiceStatus, accountId: string) {
    return this.prisma.invoice.update({
      where: { id: invoiceId },
      data: {
        status,
        updatedBy: accountId
      }
    })
  }
}
