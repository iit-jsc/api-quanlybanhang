import * as bcrypt from 'bcrypt'
import slugify from 'slugify'
import { faker } from '@faker-js/faker'
import { Injectable } from '@nestjs/common'
import { PrismaService } from 'nestjs-prisma'
import { CreateShopDto, CreateUserDto } from './dto/shop.dto'
import { DiscountType, PaymentMethodType, PrismaClient, ProductOptionType } from '@prisma/client'
import { generateCode } from 'utils/Helps'
@Injectable()
export class ShopService {
  constructor(private readonly prisma: PrismaService) {}

  async create(data: CreateShopDto) {
    console.log('üå± ƒêang setup d·ªØ li·ªáu...')

    return await this.prisma.$transaction(
      async (prisma: PrismaClient) => {
        // T·∫°o c·ª≠a h√†ng
        const newShop = await prisma.shop.create({
          data: {
            name: data.name,
            code: data.code,
            businessTypeCode: data.businessTypeCode
          },
          include: {
            businessType: true
          }
        })

        console.log('‚úÖ ƒê√£ th√™m c·ª≠a h√†ng m·ªõi!')

        // T·∫°o chi nh√°nh trong ph·∫°m vi giao d·ªãch / T·∫°o vai tr√≤
        const [newBranches, newRoles] = await Promise.all([
          this.createBranches(data.totalBranches, newShop.id, prisma),
          this.createRoles(newShop.id, prisma)
        ])

        const adminRole = newRoles.find(role => role.name === 'Qu·∫£n tr·ªã vi√™n')

        // T·∫°o ng∆∞·ªùi d√πng / nh√≥m nh√¢n vi√™n / nh√≥m kh√°ch h√†ng
        await Promise.all([
          this.createUser(
            data.user,
            newBranches.map(branch => branch.id),
            adminRole.id,
            prisma
          ),
          this.createEmployeeGroups(newShop.id, prisma),
          this.createCustomerTypes(newShop.id, prisma)
        ])

        // T·∫°o c√°c ƒë∆°n v·ªã ƒëo, lo·∫°i s·∫£n ph·∫©m v√† khu v·ª±c cho t·ª´ng chi nh√°nh trong ph·∫°m vi giao d·ªãch
        return await Promise.all(
          newBranches.map(async branch => {
            // T·∫°o measurementUnits tr∆∞·ªõc
            const measurementUnits = await this.createMeasurementUnit(
              newShop.businessType.code,
              branch.id,
              prisma
            )

            await this.createProductTypes(
              newShop.businessType.code,
              branch.id,
              measurementUnits.map(item => item.id),
              prisma
            )

            // T·∫°o areas / ph∆∞∆°ng th·ª©c thanh to√°n / topping
            await Promise.all([
              this.createAreas(branch.id, prisma),
              this.createPaymentMethods(branch.id, prisma),
              this.createProductOptionGroupsAndOptions(branch.id, data.businessTypeCode, prisma)
            ])
          })
        )
      },
      {
        maxWait: 5000,
        timeout: 10000
      }
    )
  }

  async createBranches(totalBranches: number, shopId: string, prisma: PrismaClient) {
    const branchPromises = Array.from({ length: totalBranches }, () =>
      prisma.branch.create({
        data: {
          shopId,
          name: faker.company.name(),
          photoURL: faker.image.avatar(),
          bannerURL: faker.image.imageUrl(),
          address: faker.location.streetAddress()
        }
      })
    )

    console.log('‚úÖ ƒê√£ th√™m c·ª≠a h√†ng!')

    return Promise.all(branchPromises)
  }

  async createMeasurementUnit(businessTypeCode: string, branchId: string, prisma: PrismaClient) {
    let measurementUnits = []

    if (businessTypeCode === 'FOOD_BEVERAGE') {
      measurementUnits = [
        { name: 'Ly', code: 'LY' },
        { name: 'Chai', code: 'CHAI' },
        { name: 'Kg', code: 'KG' }
      ]
    } else if (businessTypeCode === 'FASHION') {
      measurementUnits = [
        { name: 'C√°i', code: 'CAI' },
        { name: 'B·ªô', code: 'BO' },
        { name: 'ƒê√¥i', code: 'DOI' }
      ]
    }

    // D√πng Promise.all ƒë·ªÉ t·ªëi ∆∞u hi·ªáu su·∫•t
    const createdUnits = await Promise.all(
      measurementUnits.map(unit =>
        prisma.measurementUnit.create({
          data: {
            ...unit,
            branchId: branchId
          }
        })
      )
    )

    console.log('‚úÖ ƒê√£ t·∫°o ƒë∆°n v·ªã t√≠nh!')

    return createdUnits
  }

  async createRoles(shopId: string, prisma: PrismaClient) {
    // logic t·∫°o role
    const roles = [
      {
        name: 'Nh√¢n vi√™n',
        description: 'Vai tr√≤ d√†nh cho nh√¢n vi√™n c·ª≠a h√†ng',
        permissions: [
          'VIEW_AREA',
          'VIEW_TABLE',
          'ADD_DISH_TO_TABLE',
          'SEPARATE_TABLE',
          'CREATE_CUSTOMER',
          'UPDATE_CUSTOMER',
          'VIEW_CUSTOMER',
          'VIEW_CUSTOMER_TYPE',
          'VIEW_PRODUCT_TYPE',
          'VIEW_PRODUCT',
          'VIEW_MEASUREMENT_UNIT',
          'VIEW_PAYMENT_METHOD',
          'VIEW_DISCOUNT_ISSUE',
          'VIEW_DISCOUNT_CODE',
          'VIEW_EMPLOYEE_GROUP',
          'DELETE_CUSTOMER_REQUEST',
          'UPDATE_CUSTOMER_REQUEST',
          'CREATE_ORDER',
          'UPDATE_ORDER',
          'DELETE_ORDER',
          'VIEW_ORDER',
          'PAYMENT_ORDER',
          'SAVE_ORDER',
          'CANCEL_ORDER'
        ]
      },
      {
        name: 'Qu·∫£n tr·ªã vi√™n',
        description: 'Vai tr√≤ d√†nh cho qu·∫£n l√Ω c·ª≠a h√†ng',
        permissions: [
          'CREATE_AREA',
          'UPDATE_AREA',
          'DELETE_AREA',
          'VIEW_AREA',
          'CREATE_TABLE',
          'UPDATE_TABLE',
          'DELETE_TABLE',
          'VIEW_TABLE',
          'ADD_DISH_TO_TABLE',
          'SEPARATE_TABLE',
          'CREATE_ROLE',
          'UPDATE_ROLE',
          'DELETE_ROLE',
          'VIEW_ROLE',
          'CREATE_CUSTOMER',
          'UPDATE_CUSTOMER',
          'DELETE_CUSTOMER',
          'VIEW_CUSTOMER',
          'CREATE_CUSTOMER_TYPE',
          'UPDATE_CUSTOMER_TYPE',
          'DELETE_CUSTOMER_TYPE',
          'VIEW_CUSTOMER_TYPE',
          'CREATE_PRODUCT_TYPE',
          'UPDATE_PRODUCT_TYPE',
          'DELETE_PRODUCT_TYPE',
          'VIEW_PRODUCT_TYPE',
          'CREATE_PRODUCT',
          'UPDATE_PRODUCT',
          'DELETE_PRODUCT',
          'VIEW_PRODUCT',
          'CREATE_MEASUREMENT_UNIT',
          'UPDATE_MEASUREMENT_UNIT',
          'DELETE_MEASUREMENT_UNIT',
          'VIEW_MEASUREMENT_UNIT',
          'CREATE_PRODUCT_OPTION_GROUP',
          'UPDATE_PRODUCT_OPTION_GROUP',
          'DELETE_PRODUCT_OPTION_GROUP',
          'UPDATE_PAYMENT_METHOD',
          'VIEW_PAYMENT_METHOD',
          'CREATE_DISCOUNT_ISSUE',
          'UPDATE_DISCOUNT_ISSUE',
          'DELETE_DISCOUNT_ISSUE',
          'VIEW_DISCOUNT_ISSUE',
          'CREATE_DISCOUNT_CODE',
          'DELETE_DISCOUNT_CODE',
          'VIEW_DISCOUNT_CODE',
          'CREATE_VOUCHER',
          'DELETE_VOUCHER',
          'UPDATE_VOUCHER',
          'CREATE_EMPLOYEE_GROUP',
          'UPDATE_EMPLOYEE_GROUP',
          'DELETE_EMPLOYEE_GROUP',
          'VIEW_EMPLOYEE_GROUP',
          'CREATE_USER',
          'UPDATE_USER',
          'DELETE_USER',
          'VIEW_USER',
          'UPDATE_MY_INFORMATION',
          'DELETE_CUSTOMER_REQUEST',
          'UPDATE_CUSTOMER_REQUEST',
          'CREATE_ORDER',
          'UPDATE_ORDER',
          'DELETE_ORDER',
          'VIEW_ORDER',
          'PAYMENT_ORDER',
          'SAVE_ORDER',
          'CANCEL_ORDER'
        ]
      }
    ]

    const rolePromises = roles.map(role =>
      prisma.role.create({
        data: {
          name: role.name,
          description: role.description,
          shopId,
          permissions: {
            connect: role.permissions.map(code => ({ code }))
          }
        }
      })
    )

    console.log('‚úÖ ƒê√£ th√™m vai tr√≤!')

    return Promise.all(rolePromises)
  }

  async createUser(data: CreateUserDto, branchIds: string[], roleId: string, prisma: PrismaClient) {
    const user = await prisma.user.create({
      data: {
        phone: data.phone,
        name: faker.person.fullName(),
        code: faker.string.alphanumeric(6),
        address: faker.location.streetAddress(),
        cardId: faker.string.numeric(12),
        cardDate: faker.date.past(),
        cardAddress: faker.location.city(),
        birthday: faker.date.birthdate(),
        sex: faker.helpers.arrayElement(['MALE', 'FEMALE']),
        account: {
          create: {
            password: bcrypt.hashSync(data.password, 10),
            roles: {
              connect: { id: roleId }
            },
            branches: {
              connect: branchIds.map(id => ({ id }))
            }
          }
        }
      }
    })
    console.log('‚úÖ ƒê√£ t·∫°o ng∆∞·ªùi d√πng v√† t√†i kho·∫£n!')
    return user
  }

  async createEmployeeGroups(shopId: string, prisma: PrismaClient) {
    const employeeGroups = [
      {
        name: 'Nh√¢n vi√™n',
        description: 'Nh√≥m d√†nh cho nh√¢n vi√™n c·ª≠a h√†ng.'
      },
      {
        name: 'Qu·∫£n l√Ω',
        description: 'Nh√≥m d√†nh cho qu·∫£n l√Ω c·ª≠a h√†ng.'
      }
    ]

    // T·∫°o c√°c nh√≥m nh√¢n vi√™n trong c∆° s·ªü d·ªØ li·ªáu
    const groupPromises = employeeGroups.map(group =>
      prisma.employeeGroup.create({
        data: {
          name: group.name,
          description: group.description,
          shopId
        }
      })
    )

    // Ch·ªù t·∫•t c·∫£ c√°c nh√≥m ƒë∆∞·ª£c t·∫°o
    const createdGroups = await Promise.all(groupPromises)

    console.log('‚úÖ ƒê√£ t·∫°o nh√≥m nh√¢n vi√™n!')

    return createdGroups
  }

  async createProductTypes(
    businessTypeCode: string,
    branchId: string,
    measurementUnitIds: string[],
    prisma: PrismaClient
  ) {
    let productTypes = []

    if (businessTypeCode === 'FOOD_BEVERAGE') {
      productTypes = [
        {
          name: 'ƒê·ªì u·ªëng',
          description: 'C√°c lo·∫°i n∆∞·ªõc u·ªëng',
          products: ['Tr√† s·ªØa', 'C√† ph√™', 'N∆∞·ªõc cam']
        },
        { name: 'ƒê·ªì ƒÉn', description: 'C√°c m√≥n ƒÉn', products: ['B√°nh m√¨', 'C∆°m g√†', 'Ph·ªü b√≤'] },
        {
          name: 'Combo',
          description: 'G√≥i combo ti·∫øt ki·ªám',
          products: ['Combo s√°ng', 'Combo tr∆∞a', 'Combo t·ªëi']
        }
      ]
    } else if (businessTypeCode === 'FASHION') {
      productTypes = [
        {
          name: '√Åo',
          description: 'C√°c lo·∫°i √°o thun, s∆° mi, hoodie',
          products: ['√Åo thun', '√Åo s∆° mi', 'Hoodie']
        },
        {
          name: 'Qu·∫ßn',
          description: 'Qu·∫ßn jeans, qu·∫ßn kaki, qu·∫ßn short',
          products: ['Jeans', 'Kaki', 'Short']
        },
        {
          name: 'Gi√†y D√©p',
          description: 'C√°c lo·∫°i gi√†y sneaker, sandal',
          products: ['Sneaker', 'Sandal', 'Gi√†y l∆∞·ªùi']
        }
      ]
    }

    if (productTypes.length === 0) {
      return []
    }

    const createdProductTypes = await Promise.all(
      productTypes.map(async type => {
        const createdType = await prisma.productType.create({
          data: {
            name: type.name,
            slug: slugify(type.name),
            description: type.description,
            branchId: branchId
          }
        })

        // N·∫øu kh√¥ng c√≥ ƒë∆°n v·ªã ƒëo n√†o, kh√¥ng t·∫°o s·∫£n ph·∫©m
        if (measurementUnitIds.length === 0) {
          return { createdType, createdProducts: [] }
        }

        // T·∫°o s·∫£n ph·∫©m
        const createdProducts = await Promise.all(
          type.products.map(productName => {
            const unitId = measurementUnitIds[Math.floor(Math.random() * measurementUnitIds.length)]
            return prisma.product.create({
              data: {
                name: productName,
                slug: `${slugify(productName)}-${generateCode('')}`,
                branchId: branchId,
                unitId: unitId,
                productTypeId: createdType.id,
                price: faker.number.float({ min: 10000, max: 500000, precision: 1000 }),
                code: generateCode('SP'),
                oldPrice: faker.number.float({ min: 10000, max: 500000, precision: 1000 }),
                description: faker.commerce.productDescription(),
                thumbnail: faker.image.urlPicsumPhotos(),
                photoURLs: [faker.image.url(), faker.image.url()]
              }
            })
          })
        )

        return { createdType, createdProducts }
      })
    )

    console.log('‚úÖ ƒê√£ t·∫°o lo·∫°i s·∫£n ph·∫©m!')

    return createdProductTypes
  }

  async createAreas(branchId: string, prisma: PrismaClient) {
    const areasData = [
      {
        name: 'Khu v·ª±c A',
        tables: [
          { name: 'B√†n 1', seat: 4 },
          { name: 'B√†n 2', seat: 4 },
          { name: 'B√†n 3', seat: 2 }
        ]
      },
      {
        name: 'Khu v·ª±c B',
        tables: [
          { name: 'B√†n 1', seat: 6 },
          { name: 'B√†n 2', seat: 2 }
        ]
      }
    ]

    console.log('‚úÖ ƒê√£ t·∫°o khu v·ª±c!')

    return await Promise.all(
      areasData.map(async areaData => {
        return await prisma.area.create({
          data: {
            name: areaData.name,
            branchId: branchId,
            tables: {
              create: areaData.tables.map(table => ({
                name: table.name,
                seat: table.seat,
                branchId
              }))
            }
          }
        })
      })
    )
  }

  async createCustomerTypes(shopId: string, prisma: PrismaClient) {
    const customerTypes = [
      {
        name: 'Kh√°ch VIP',
        description: 'Kh√°ch h√†ng th√¢n thi·∫øt, ƒë∆∞·ª£c h∆∞·ªüng nhi·ªÅu ∆∞u ƒë√£i.',
        discount: 10,
        discountType: DiscountType.PERCENT
      },
      {
        name: 'Kh√°ch v√£ng lai',
        description: 'Kh√°ch h√†ng kh√¥ng c√≥ ∆∞u ƒë√£i ƒë·∫∑c bi·ªát.',
        discount: 0,
        discountType: DiscountType.VALUE
      }
    ]

    const createdCustomerTypes = await Promise.all(
      customerTypes.map(customerType =>
        prisma.customerType.create({
          data: {
            name: customerType.name,
            description: customerType.description,
            discount: customerType.discount,
            discountType: customerType.discountType,
            shopId: shopId
          }
        })
      )
    )

    console.log('‚úÖ ƒê√£ t·∫°o nh√≥m kh√°ch h√†ng!')

    return createdCustomerTypes
  }

  async createPaymentMethods(branchId: string, prisma: PrismaClient) {
    const paymentMethods = [
      {
        bankName: 'Vietcombank',
        bankCode: 'VCB123',
        representative: 'Nguy·ªÖn VƒÉn A',
        type: PaymentMethodType.BANKING,
        active: false
      },
      {
        bankName: null,
        bankCode: null,
        representative: null,
        type: PaymentMethodType.QR_CODE,
        active: false
      },
      {
        bankName: null,
        bankCode: null,
        representative: null,
        type: PaymentMethodType.CASH,
        active: true
      }
    ]

    // D√πng Prisma ƒë·ªÉ t·∫°o c√°c ph∆∞∆°ng th·ª©c thanh to√°n cho chi nh√°nh
    const createdPaymentMethods = await prisma.paymentMethod.createMany({
      data: paymentMethods.map(paymentMethod => ({
        branchId,
        bankName: paymentMethod.bankName,
        bankCode: paymentMethod.bankCode,
        representative: paymentMethod.representative,
        type: paymentMethod.type,
        active: paymentMethod.active
      }))
    })

    console.log('‚úÖ ƒê√£ t·∫°o ph∆∞∆°ng th·ª©c thanh to√°n!')

    return createdPaymentMethods
  }

  async createProductOptionGroupsAndOptions(
    branchId: string,
    businessTypeCode: string,
    prisma: PrismaClient
  ) {
    let productOptionGroups = []

    if (businessTypeCode === 'FOOD_BEVERAGE') {
      // T·∫°o nh√≥m s·∫£n ph·∫©m cho qu√°n ƒÉn u·ªëng
      productOptionGroups = [
        {
          name: 'Size',
          isMultiple: false,
          isRequired: true,
          productOptions: [
            { name: 'M', price: 0, type: ProductOptionType.APPLY_ALL, isDefault: true }, // Size M
            { name: 'L', price: 0, type: ProductOptionType.APPLY_ALL, isDefault: false } // Size L
          ]
        },
        {
          name: 'Topping',
          isMultiple: true,
          isRequired: false,
          productOptions: [
            { name: 'Tr√¢n ch√¢u', price: 5000, type: ProductOptionType.APPLY_ALL, isDefault: false },
            { name: 'ƒê·∫≠u ƒë·ªè', price: 4000, type: ProductOptionType.APPLY_ALL, isDefault: false },
            { name: 'ƒê·∫≠u xanh', price: 2000, type: ProductOptionType.APPLY_ALL, isDefault: false }
          ]
        },
        {
          name: 'Ch√¢n ch√¢u',
          isMultiple: true,
          isRequired: false,
          productOptions: [
            {
              name: 'Ch√¢n ch√¢u ƒëen',
              price: 3000,
              type: ProductOptionType.APPLY_ALL,
              isDefault: false
            },
            {
              name: 'Ch√¢n ch√¢u tr·∫Øng',
              price: 5000,
              type: ProductOptionType.APPLY_ALL,
              isDefault: false
            }
          ]
        }
      ]
    } else if (businessTypeCode === 'FASHION') {
      // T·∫°o nh√≥m s·∫£n ph·∫©m cho qu·∫ßn √°o
      productOptionGroups = [
        {
          name: 'Size',
          isMultiple: false,
          isRequired: true,
          productOptions: [
            { name: 'S', price: 0, type: ProductOptionType.APPLY_ALL, isDefault: false },
            { name: 'M', price: 0, type: ProductOptionType.APPLY_ALL, isDefault: true },
            { name: 'L', price: 0, type: ProductOptionType.APPLY_ALL, isDefault: false },
            { name: 'XL', price: 0, type: ProductOptionType.APPLY_ALL, isDefault: false }
          ]
        },
        {
          name: 'M√†u s·∫Øc',
          isMultiple: false,
          isRequired: true,
          productOptions: [
            { name: 'ƒêen', price: 0, type: ProductOptionType.APPLY_ALL, isDefault: false },
            { name: 'Tr·∫Øng', price: 0, type: ProductOptionType.APPLY_ALL, isDefault: false }
          ]
        }
      ]
    }

    console.log('‚úÖ ƒê√£ t·∫°o nh√≥m t√πy ch·ªçn!')

    // Th√™m v√†o c∆° s·ªü d·ªØ li·ªáu
    return await Promise.all(
      productOptionGroups.map(async group => {
        return prisma.productOptionGroup.create({
          data: {
            name: group.name,
            isMultiple: group.isMultiple,
            isRequired: group.isRequired,
            branchId,
            productOptions: {
              create: group.productOptions.map(option => ({
                name: option.name,
                price: option.price,
                type: option.type,
                isDefault: option.isDefault
              }))
            }
          }
        })
      })
    )
  }
}
